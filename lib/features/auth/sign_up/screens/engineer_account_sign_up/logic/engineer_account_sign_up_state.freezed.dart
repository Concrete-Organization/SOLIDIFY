// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'engineer_account_sign_up_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$EngineerAccountSignUpState<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() engineerSignUpLoading,
    required TResult Function(T data) engineerSignUpSuccess,
    required TResult Function(ApiErrorModel error) engineerSignUpError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? engineerSignUpLoading,
    TResult? Function(T data)? engineerSignUpSuccess,
    TResult? Function(ApiErrorModel error)? engineerSignUpError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
  TResult Function()? initial,
  TResult Function()? engineerSignUpLoading,
  TResult Function(T data)? engineerSignUpSuccess,
  TResult Function(ApiErrorModel error)? engineerSignUpError,
  required TResult orElse(),
}) =>
throw _privateConstructorUsedError;
@optionalTypeArgs
TResult map<TResult extends Object?>({
  required TResult Function(_Initial<T> value) initial,
  required TResult Function(EngineerAccountSignUpLoading<T> value)
  engineerSignUpLoading,
  required TResult Function(EngineerAccountSignUpSuccess<T> value)
  engineerSignUpSuccess,
  required TResult Function(EngineerAccountSignUpError<T> value)
  engineerSignUpError,
}) =>
    throw _privateConstructorUsedError;
@optionalTypeArgs
TResult? mapOrNull<TResult extends Object?>({
  TResult? Function(_Initial<T> value)? initial,
  TResult? Function(EngineerAccountSignUpLoading<T> value)?
  engineerSignUpLoading,
  TResult? Function(EngineerAccountSignUpSuccess<T> value)?
  engineerSignUpSuccess,
  TResult? Function(EngineerAccountSignUpError<T> value)? engineerSignUpError,
}) =>
    throw _privateConstructorUsedError;
@optionalTypeArgs
TResult maybeMap<TResult extends Object?>({
TResult Function(_Initial<T> value)? initial,
TResult Function(EngineerAccountSignUpLoading<T> value)?
engineerSignUpLoading,
TResult Function(EngineerAccountSignUpSuccess<T> value)?
engineerSignUpSuccess,
TResult Function(EngineerAccountSignUpError<T> value)? engineerSignUpError,
required TResult orElse(),
}) =>
throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EngineerAccountSignUpStateCopyWith<T, $Res> {
factory $EngineerAccountSignUpStateCopyWith(
EngineerAccountSignUpState<T> value,
$Res Function(EngineerAccountSignUpState<T>) then) =
_$EngineerAccountSignUpStateCopyWithImpl<T, $Res,
EngineerAccountSignUpState<T>>;
}

/// @nodoc
class _$EngineerAccountSignUpStateCopyWithImpl<T, $Res,
$Val extends EngineerAccountSignUpState<T>>
implements $EngineerAccountSignUpStateCopyWith<T, $Res> {
_$EngineerAccountSignUpStateCopyWithImpl(this._value, this._then);

// ignore: unused_field
final $Val _value;
// ignore: unused_field
final $Res Function($Val) _then;

/// Create a copy of EngineerAccountSignUpState
/// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InitialImplCopyWith<T, $Res> {
factory _$$InitialImplCopyWith(
_$InitialImpl<T> value, $Res Function(_$InitialImpl<T>) then) =
__$$InitialImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<T, $Res>
extends _$EngineerAccountSignUpStateCopyWithImpl<T, $Res, _$InitialImpl<T>>
implements _$$InitialImplCopyWith<T, $Res> {
__$$InitialImplCopyWithImpl(
_$InitialImpl<T> _value, $Res Function(_$InitialImpl<T>) _then)
    : super(_value, _then);

/// Create a copy of EngineerAccountSignUpState
/// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitialImpl<T> implements _Initial<T> {
const _$InitialImpl();

@override
String toString() {
return 'EngineerAccountSignUpState<$T>.initial()';
}

@override
bool operator ==(Object other) {
return identical(this, other) ||
(other.runtimeType == runtimeType && other is _$InitialImpl<T>);
}

@override
int get hashCode => runtimeType.hashCode;

@override
@optionalTypeArgs
TResult when<TResult extends Object?>({
required TResult Function() initial,
required TResult Function() engineerSignUpLoading,
required TResult Function(T data) engineerSignUpSuccess,
required TResult Function(ApiErrorModel error) engineerSignUpError,
}) {
return initial();
}

@override
@optionalTypeArgs
TResult? whenOrNull<TResult extends Object?>({
TResult? Function()? initial,
TResult? Function()? engineerSignUpLoading,
TResult? Function(T data)? engineerSignUpSuccess,
TResult? Function(ApiErrorModel error)? engineerSignUpError,
}) {
return initial?.call();
}

@override
@optionalTypeArgs
TResult maybeWhen<TResult extends Object?>({
TResult Function()? initial,
TResult Function()? engineerSignUpLoading,
TResult Function(T data)? engineerSignUpSuccess,
TResult Function(ApiErrorModel error)? engineerSignUpError,
required TResult orElse(),
}) {
if (initial != null) {
return initial();
}
return orElse();
}

@override
@optionalTypeArgs
TResult map<TResult extends Object?>({
required TResult Function(_Initial<T> value) initial,
required TResult Function(EngineerAccountSignUpLoading<T> value)
engineerSignUpLoading,
required TResult Function(EngineerAccountSignUpSuccess<T> value)
engineerSignUpSuccess,
required TResult Function(EngineerAccountSignUpError<T> value)
engineerSignUpError,
}) {
return initial(this);
}

@override
@optionalTypeArgs
TResult? mapOrNull<TResult extends Object?>({
TResult? Function(_Initial<T> value)? initial,
TResult? Function(EngineerAccountSignUpLoading<T> value)?
engineerSignUpLoading,
TResult? Function(EngineerAccountSignUpSuccess<T> value)?
engineerSignUpSuccess,
TResult? Function(EngineerAccountSignUpError<T> value)? engineerSignUpError,
}) {
return initial?.call(this);
}

@override
@optionalTypeArgs
TResult maybeMap<TResult extends Object?>({
TResult Function(_Initial<T> value)? initial,
TResult Function(EngineerAccountSignUpLoading<T> value)?
engineerSignUpLoading,
TResult Function(EngineerAccountSignUpSuccess<T> value)?
engineerSignUpSuccess,
TResult Function(EngineerAccountSignUpError<T> value)? engineerSignUpError,
required TResult orElse(),
}) {
if (initial != null) {
return initial(this);
}
return orElse();
}
}

abstract class _Initial<T> implements EngineerAccountSignUpState<T> {
const factory _Initial() = _$InitialImpl<T>;
}

/// @nodoc
abstract class _$$EngineerAccountSignUpLoadingImplCopyWith<T, $Res> {
factory _$$EngineerAccountSignUpLoadingImplCopyWith(
_$EngineerAccountSignUpLoadingImpl<T> value,
$Res Function(_$EngineerAccountSignUpLoadingImpl<T>) then) =
__$$EngineerAccountSignUpLoadingImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$EngineerAccountSignUpLoadingImplCopyWithImpl<T, $Res>
extends _$EngineerAccountSignUpStateCopyWithImpl<T, $Res,
_$EngineerAccountSignUpLoadingImpl<T>>
implements _$$EngineerAccountSignUpLoadingImplCopyWith<T, $Res> {
__$$EngineerAccountSignUpLoadingImplCopyWithImpl(
_$EngineerAccountSignUpLoadingImpl<T> _value,
$Res Function(_$EngineerAccountSignUpLoadingImpl<T>) _then)
    : super(_value, _then);

/// Create a copy of EngineerAccountSignUpState
/// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$EngineerAccountSignUpLoadingImpl<T>
implements EngineerAccountSignUpLoading<T> {
const _$EngineerAccountSignUpLoadingImpl();

@override
String toString() {
return 'EngineerAccountSignUpState<$T>.engineerSignUpLoading()';
}

@override
bool operator ==(Object other) {
return identical(this, other) ||
(other.runtimeType == runtimeType &&
other is _$EngineerAccountSignUpLoadingImpl<T>);
}

@override
int get hashCode => runtimeType.hashCode;

@override
@optionalTypeArgs
TResult when<TResult extends Object?>({
required TResult Function() initial,
required TResult Function() engineerSignUpLoading,
required TResult Function(T data) engineerSignUpSuccess,
required TResult Function(ApiErrorModel error) engineerSignUpError,
}) {
return engineerSignUpLoading();
}

@override
@optionalTypeArgs
TResult? whenOrNull<TResult extends Object?>({
TResult? Function()? initial,
TResult? Function()? engineerSignUpLoading,
TResult? Function(T data)? engineerSignUpSuccess,
TResult? Function(ApiErrorModel error)? engineerSignUpError,
}) {
return engineerSignUpLoading?.call();
}

@override
@optionalTypeArgs
TResult maybeWhen<TResult extends Object?>({
TResult Function()? initial,
TResult Function()? engineerSignUpLoading,
TResult Function(T data)? engineerSignUpSuccess,
TResult Function(ApiErrorModel error)? engineerSignUpError,
required TResult orElse(),
}) {
if (engineerSignUpLoading != null) {
return engineerSignUpLoading();
}
return orElse();
}

@override
@optionalTypeArgs
TResult map<TResult extends Object?>({
required TResult Function(_Initial<T> value) initial,
required TResult Function(EngineerAccountSignUpLoading<T> value)
engineerSignUpLoading,
required TResult Function(EngineerAccountSignUpSuccess<T> value)
engineerSignUpSuccess,
required TResult Function(EngineerAccountSignUpError<T> value)
engineerSignUpError,
}) {
return engineerSignUpLoading(this);
}

@override
@optionalTypeArgs
TResult? mapOrNull<TResult extends Object?>({
TResult? Function(_Initial<T> value)? initial,
TResult? Function(EngineerAccountSignUpLoading<T> value)?
engineerSignUpLoading,
TResult? Function(EngineerAccountSignUpSuccess<T> value)?
engineerSignUpSuccess,
TResult? Function(EngineerAccountSignUpError<T> value)? engineerSignUpError,
}) {
return engineerSignUpLoading?.call(this);
}

@override
@optionalTypeArgs
TResult maybeMap<TResult extends Object?>({
TResult Function(_Initial<T> value)? initial,
TResult Function(EngineerAccountSignUpLoading<T> value)?
engineerSignUpLoading,
TResult Function(EngineerAccountSignUpSuccess<T> value)?
engineerSignUpSuccess,
TResult Function(EngineerAccountSignUpError<T> value)? engineerSignUpError,
required TResult orElse(),
}) {
if (engineerSignUpLoading != null) {
return engineerSignUpLoading(this);
}
return orElse();
}
}

abstract class EngineerAccountSignUpLoading<T>
implements EngineerAccountSignUpState<T> {
const factory EngineerAccountSignUpLoading() =
_$EngineerAccountSignUpLoadingImpl<T>;
}

/// @nodoc
abstract class _$$EngineerAccountSignUpSuccessImplCopyWith<T, $Res> {
factory _$$EngineerAccountSignUpSuccessImplCopyWith(
_$EngineerAccountSignUpSuccessImpl<T> value,
$Res Function(_$EngineerAccountSignUpSuccessImpl<T>) then) =
__$$EngineerAccountSignUpSuccessImplCopyWithImpl<T, $Res>;
@useResult
$Res call({T data});
}

/// @nodoc
class __$$EngineerAccountSignUpSuccessImplCopyWithImpl<T, $Res>
extends _$EngineerAccountSignUpStateCopyWithImpl<T, $Res,
_$EngineerAccountSignUpSuccessImpl<T>>
implements _$$EngineerAccountSignUpSuccessImplCopyWith<T, $Res> {
__$$EngineerAccountSignUpSuccessImplCopyWithImpl(
_$EngineerAccountSignUpSuccessImpl<T> _value,
$Res Function(_$EngineerAccountSignUpSuccessImpl<T>) _then)
    : super(_value, _then);

/// Create a copy of EngineerAccountSignUpState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline')
@override
$Res call({
Object? data = freezed,
}) {
return _then(_$EngineerAccountSignUpSuccessImpl<T>(
freezed == data
? _value.data
    : data // ignore: cast_nullable_to_non_nullable
as T,
));
}
}

/// @nodoc

class _$EngineerAccountSignUpSuccessImpl<T>
implements EngineerAccountSignUpSuccess<T> {
const _$EngineerAccountSignUpSuccessImpl(this.data);

@override
final T data;

@override
String toString() {
return 'EngineerAccountSignUpState<$T>.engineerSignUpSuccess(data: $data)';
}

@override
bool operator ==(Object other) {
return identical(this, other) ||
(other.runtimeType == runtimeType &&
other is _$EngineerAccountSignUpSuccessImpl<T> &&
const DeepCollectionEquality().equals(other.data, data));
}

@override
int get hashCode =>
Object.hash(runtimeType, const DeepCollectionEquality().hash(data));

/// Create a copy of EngineerAccountSignUpState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@override
@pragma('vm:prefer-inline')
_$$EngineerAccountSignUpSuccessImplCopyWith<T,
_$EngineerAccountSignUpSuccessImpl<T>>
get copyWith => __$$EngineerAccountSignUpSuccessImplCopyWithImpl<T,
_$EngineerAccountSignUpSuccessImpl<T>>(this, _$identity);

@override
@optionalTypeArgs
TResult when<TResult extends Object?>({
required TResult Function() initial,
required TResult Function() engineerSignUpLoading,
required TResult Function(T data) engineerSignUpSuccess,
required TResult Function(ApiErrorModel error) engineerSignUpError,
}) {
return engineerSignUpSuccess(data);
}

@override
@optionalTypeArgs
TResult? whenOrNull<TResult extends Object?>({
TResult? Function()? initial,
TResult? Function()? engineerSignUpLoading,
TResult? Function(T data)? engineerSignUpSuccess,
TResult? Function(ApiErrorModel error)? engineerSignUpError,
}) {
return engineerSignUpSuccess?.call(data);
}

@override
@optionalTypeArgs
TResult maybeWhen<TResult extends Object?>({
TResult Function()? initial,
TResult Function()? engineerSignUpLoading,
TResult Function(T data)? engineerSignUpSuccess,
TResult Function(ApiErrorModel error)? engineerSignUpError,
required TResult orElse(),
}) {
if (engineerSignUpSuccess != null) {
return engineerSignUpSuccess(data);
}
return orElse();
}

@override
@optionalTypeArgs
TResult map<TResult extends Object?>({
required TResult Function(_Initial<T> value) initial,
required TResult Function(EngineerAccountSignUpLoading<T> value)
engineerSignUpLoading,
required TResult Function(EngineerAccountSignUpSuccess<T> value)
engineerSignUpSuccess,
required TResult Function(EngineerAccountSignUpError<T> value)
engineerSignUpError,
}) {
return engineerSignUpSuccess(this);
}

@override
@optionalTypeArgs
TResult? mapOrNull<TResult extends Object?>({
TResult? Function(_Initial<T> value)? initial,
TResult? Function(EngineerAccountSignUpLoading<T> value)?
engineerSignUpLoading,
TResult? Function(EngineerAccountSignUpSuccess<T> value)?
engineerSignUpSuccess,
TResult? Function(EngineerAccountSignUpError<T> value)? engineerSignUpError,
}) {
return engineerSignUpSuccess?.call(this);
}

@override
@optionalTypeArgs
TResult maybeMap<TResult extends Object?>({
TResult Function(_Initial<T> value)? initial,
TResult Function(EngineerAccountSignUpLoading<T> value)?
engineerSignUpLoading,
TResult Function(EngineerAccountSignUpSuccess<T> value)?
engineerSignUpSuccess,
TResult Function(EngineerAccountSignUpError<T> value)? engineerSignUpError,
required TResult orElse(),
}) {
if (engineerSignUpSuccess != null) {
return engineerSignUpSuccess(this);
}
return orElse();
}
}

abstract class EngineerAccountSignUpSuccess<T>
implements EngineerAccountSignUpState<T> {
const factory EngineerAccountSignUpSuccess(final T data) =
_$EngineerAccountSignUpSuccessImpl<T>;

T get data;

/// Create a copy of EngineerAccountSignUpState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
_$$EngineerAccountSignUpSuccessImplCopyWith<T,
_$EngineerAccountSignUpSuccessImpl<T>>
get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EngineerAccountSignUpErrorImplCopyWith<T, $Res> {
factory _$$EngineerAccountSignUpErrorImplCopyWith(
_$EngineerAccountSignUpErrorImpl<T> value,
$Res Function(_$EngineerAccountSignUpErrorImpl<T>) then) =
__$$EngineerAccountSignUpErrorImplCopyWithImpl<T, $Res>;
@useResult
$Res call({ApiErrorModel error});
}

/// @nodoc
class __$$EngineerAccountSignUpErrorImplCopyWithImpl<T, $Res>
extends _$EngineerAccountSignUpStateCopyWithImpl<T, $Res,
_$EngineerAccountSignUpErrorImpl<T>>
implements _$$EngineerAccountSignUpErrorImplCopyWith<T, $Res> {
__$$EngineerAccountSignUpErrorImplCopyWithImpl(
_$EngineerAccountSignUpErrorImpl<T> _value,
$Res Function(_$EngineerAccountSignUpErrorImpl<T>) _then)
    : super(_value, _then);

/// Create a copy of EngineerAccountSignUpState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline')
@override
$Res call({
Object? error = null,
}) {
return _then(_$EngineerAccountSignUpErrorImpl<T>(
error: null == error
? _value.error
    : error // ignore: cast_nullable_to_non_nullable
as ApiErrorModel,
));
}
}

/// @nodoc

class _$EngineerAccountSignUpErrorImpl<T>
implements EngineerAccountSignUpError<T> {
const _$EngineerAccountSignUpErrorImpl({required this.error});

@override
final ApiErrorModel error;

@override
String toString() {
return 'EngineerAccountSignUpState<$T>.engineerSignUpError(error: $error)';
}

@override
bool operator ==(Object other) {
return identical(this, other) ||
(other.runtimeType == runtimeType &&
other is _$EngineerAccountSignUpErrorImpl<T> &&
(identical(other.error, error) || other.error == error));
}

@override
int get hashCode => Object.hash(runtimeType, error);

/// Create a copy of EngineerAccountSignUpState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@override
@pragma('vm:prefer-inline')
_$$EngineerAccountSignUpErrorImplCopyWith<T,
_$EngineerAccountSignUpErrorImpl<T>>
get copyWith => __$$EngineerAccountSignUpErrorImplCopyWithImpl<T,
_$EngineerAccountSignUpErrorImpl<T>>(this, _$identity);

@override
@optionalTypeArgs
TResult when<TResult extends Object?>({
required TResult Function() initial,
required TResult Function() engineerSignUpLoading,
required TResult Function(T data) engineerSignUpSuccess,
required TResult Function(ApiErrorModel error) engineerSignUpError,
}) {
return engineerSignUpError(error);
}

@override
@optionalTypeArgs
TResult? whenOrNull<TResult extends Object?>({
TResult? Function()? initial,
TResult? Function()? engineerSignUpLoading,
TResult? Function(T data)? engineerSignUpSuccess,
TResult? Function(ApiErrorModel error)? engineerSignUpError,
}) {
return engineerSignUpError?.call(error);
}

@override
@optionalTypeArgs
TResult maybeWhen<TResult extends Object?>({
TResult Function()? initial,
TResult Function()? engineerSignUpLoading,
TResult Function(T data)? engineerSignUpSuccess,
TResult Function(ApiErrorModel error)? engineerSignUpError,
required TResult orElse(),
}) {
if (engineerSignUpError != null) {
return engineerSignUpError(error);
}
return orElse();
}

@override
@optionalTypeArgs
TResult map<TResult extends Object?>({
required TResult Function(_Initial<T> value) initial,
required TResult Function(EngineerAccountSignUpLoading<T> value)
engineerSignUpLoading,
required TResult Function(EngineerAccountSignUpSuccess<T> value)
engineerSignUpSuccess,
required TResult Function(EngineerAccountSignUpError<T> value)
engineerSignUpError,
}) {
return engineerSignUpError(this);
}

@override
@optionalTypeArgs
TResult? mapOrNull<TResult extends Object?>({
TResult? Function(_Initial<T> value)? initial,
TResult? Function(EngineerAccountSignUpLoading<T> value)?
engineerSignUpLoading,
TResult? Function(EngineerAccountSignUpSuccess<T> value)?
engineerSignUpSuccess,
TResult? Function(EngineerAccountSignUpError<T> value)? engineerSignUpError,
}) {
return engineerSignUpError?.call(this);
}

@override
@optionalTypeArgs
TResult maybeMap<TResult extends Object?>({
TResult Function(_Initial<T> value)? initial,
TResult Function(EngineerAccountSignUpLoading<T> value)?
engineerSignUpLoading,
TResult Function(EngineerAccountSignUpSuccess<T> value)?
engineerSignUpSuccess,
TResult Function(EngineerAccountSignUpError<T> value)? engineerSignUpError,
required TResult orElse(),
}) {
if (engineerSignUpError != null) {
return engineerSignUpError(this);
}
return orElse();
}
}

abstract class EngineerAccountSignUpError<T>
implements EngineerAccountSignUpState<T> {
const factory EngineerAccountSignUpError(
{required final ApiErrorModel error}) =
_$EngineerAccountSignUpErrorImpl<T>;

ApiErrorModel get error;

/// Create a copy of EngineerAccountSignUpState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
_$$EngineerAccountSignUpErrorImplCopyWith<T,
_$EngineerAccountSignUpErrorImpl<T>>
get copyWith => throw _privateConstructorUsedError;
}