// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'comments_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$CommentsState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() commentsLoading,
    required TResult Function(
            List<CommentModel> comments, CommentModel? replyingToComment)
        commentsSuccess,
    required TResult Function(ApiErrorModel error) commentsError,
    required TResult Function() createCommentLoading,
    required TResult Function(CreateCommentResponse response)
        createCommentSuccess,
    required TResult Function(ApiErrorModel error) createCommentError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? commentsLoading,
    TResult? Function(
            List<CommentModel> comments, CommentModel? replyingToComment)?
        commentsSuccess,
    TResult? Function(ApiErrorModel error)? commentsError,
    TResult? Function()? createCommentLoading,
    TResult? Function(CreateCommentResponse response)? createCommentSuccess,
    TResult? Function(ApiErrorModel error)? createCommentError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? commentsLoading,
    TResult Function(
            List<CommentModel> comments, CommentModel? replyingToComment)?
        commentsSuccess,
    TResult Function(ApiErrorModel error)? commentsError,
    TResult Function()? createCommentLoading,
    TResult Function(CreateCommentResponse response)? createCommentSuccess,
    TResult Function(ApiErrorModel error)? createCommentError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(CommentsLoading value) commentsLoading,
    required TResult Function(CommentsSuccess value) commentsSuccess,
    required TResult Function(CommentsError value) commentsError,
    required TResult Function(CreateCommentLoading value) createCommentLoading,
    required TResult Function(CreateCommentSuccess value) createCommentSuccess,
    required TResult Function(CreateCommentError value) createCommentError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(CommentsLoading value)? commentsLoading,
    TResult? Function(CommentsSuccess value)? commentsSuccess,
    TResult? Function(CommentsError value)? commentsError,
    TResult? Function(CreateCommentLoading value)? createCommentLoading,
    TResult? Function(CreateCommentSuccess value)? createCommentSuccess,
    TResult? Function(CreateCommentError value)? createCommentError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(CommentsLoading value)? commentsLoading,
    TResult Function(CommentsSuccess value)? commentsSuccess,
    TResult Function(CommentsError value)? commentsError,
    TResult Function(CreateCommentLoading value)? createCommentLoading,
    TResult Function(CreateCommentSuccess value)? createCommentSuccess,
    TResult Function(CreateCommentError value)? createCommentError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CommentsStateCopyWith<$Res> {
  factory $CommentsStateCopyWith(
          CommentsState value, $Res Function(CommentsState) then) =
      _$CommentsStateCopyWithImpl<$Res, CommentsState>;
}

/// @nodoc
class _$CommentsStateCopyWithImpl<$Res, $Val extends CommentsState>
    implements $CommentsStateCopyWith<$Res> {
  _$CommentsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CommentsState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$CommentsStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of CommentsState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'CommentsState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() commentsLoading,
    required TResult Function(
            List<CommentModel> comments, CommentModel? replyingToComment)
        commentsSuccess,
    required TResult Function(ApiErrorModel error) commentsError,
    required TResult Function() createCommentLoading,
    required TResult Function(CreateCommentResponse response)
        createCommentSuccess,
    required TResult Function(ApiErrorModel error) createCommentError,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? commentsLoading,
    TResult? Function(
            List<CommentModel> comments, CommentModel? replyingToComment)?
        commentsSuccess,
    TResult? Function(ApiErrorModel error)? commentsError,
    TResult? Function()? createCommentLoading,
    TResult? Function(CreateCommentResponse response)? createCommentSuccess,
    TResult? Function(ApiErrorModel error)? createCommentError,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? commentsLoading,
    TResult Function(
            List<CommentModel> comments, CommentModel? replyingToComment)?
        commentsSuccess,
    TResult Function(ApiErrorModel error)? commentsError,
    TResult Function()? createCommentLoading,
    TResult Function(CreateCommentResponse response)? createCommentSuccess,
    TResult Function(ApiErrorModel error)? createCommentError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(CommentsLoading value) commentsLoading,
    required TResult Function(CommentsSuccess value) commentsSuccess,
    required TResult Function(CommentsError value) commentsError,
    required TResult Function(CreateCommentLoading value) createCommentLoading,
    required TResult Function(CreateCommentSuccess value) createCommentSuccess,
    required TResult Function(CreateCommentError value) createCommentError,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(CommentsLoading value)? commentsLoading,
    TResult? Function(CommentsSuccess value)? commentsSuccess,
    TResult? Function(CommentsError value)? commentsError,
    TResult? Function(CreateCommentLoading value)? createCommentLoading,
    TResult? Function(CreateCommentSuccess value)? createCommentSuccess,
    TResult? Function(CreateCommentError value)? createCommentError,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(CommentsLoading value)? commentsLoading,
    TResult Function(CommentsSuccess value)? commentsSuccess,
    TResult Function(CommentsError value)? commentsError,
    TResult Function(CreateCommentLoading value)? createCommentLoading,
    TResult Function(CreateCommentSuccess value)? createCommentSuccess,
    TResult Function(CreateCommentError value)? createCommentError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements CommentsState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$CommentsLoadingImplCopyWith<$Res> {
  factory _$$CommentsLoadingImplCopyWith(_$CommentsLoadingImpl value,
          $Res Function(_$CommentsLoadingImpl) then) =
      __$$CommentsLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CommentsLoadingImplCopyWithImpl<$Res>
    extends _$CommentsStateCopyWithImpl<$Res, _$CommentsLoadingImpl>
    implements _$$CommentsLoadingImplCopyWith<$Res> {
  __$$CommentsLoadingImplCopyWithImpl(
      _$CommentsLoadingImpl _value, $Res Function(_$CommentsLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of CommentsState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$CommentsLoadingImpl implements CommentsLoading {
  const _$CommentsLoadingImpl();

  @override
  String toString() {
    return 'CommentsState.commentsLoading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CommentsLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() commentsLoading,
    required TResult Function(
            List<CommentModel> comments, CommentModel? replyingToComment)
        commentsSuccess,
    required TResult Function(ApiErrorModel error) commentsError,
    required TResult Function() createCommentLoading,
    required TResult Function(CreateCommentResponse response)
        createCommentSuccess,
    required TResult Function(ApiErrorModel error) createCommentError,
  }) {
    return commentsLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? commentsLoading,
    TResult? Function(
            List<CommentModel> comments, CommentModel? replyingToComment)?
        commentsSuccess,
    TResult? Function(ApiErrorModel error)? commentsError,
    TResult? Function()? createCommentLoading,
    TResult? Function(CreateCommentResponse response)? createCommentSuccess,
    TResult? Function(ApiErrorModel error)? createCommentError,
  }) {
    return commentsLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? commentsLoading,
    TResult Function(
            List<CommentModel> comments, CommentModel? replyingToComment)?
        commentsSuccess,
    TResult Function(ApiErrorModel error)? commentsError,
    TResult Function()? createCommentLoading,
    TResult Function(CreateCommentResponse response)? createCommentSuccess,
    TResult Function(ApiErrorModel error)? createCommentError,
    required TResult orElse(),
  }) {
    if (commentsLoading != null) {
      return commentsLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(CommentsLoading value) commentsLoading,
    required TResult Function(CommentsSuccess value) commentsSuccess,
    required TResult Function(CommentsError value) commentsError,
    required TResult Function(CreateCommentLoading value) createCommentLoading,
    required TResult Function(CreateCommentSuccess value) createCommentSuccess,
    required TResult Function(CreateCommentError value) createCommentError,
  }) {
    return commentsLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(CommentsLoading value)? commentsLoading,
    TResult? Function(CommentsSuccess value)? commentsSuccess,
    TResult? Function(CommentsError value)? commentsError,
    TResult? Function(CreateCommentLoading value)? createCommentLoading,
    TResult? Function(CreateCommentSuccess value)? createCommentSuccess,
    TResult? Function(CreateCommentError value)? createCommentError,
  }) {
    return commentsLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(CommentsLoading value)? commentsLoading,
    TResult Function(CommentsSuccess value)? commentsSuccess,
    TResult Function(CommentsError value)? commentsError,
    TResult Function(CreateCommentLoading value)? createCommentLoading,
    TResult Function(CreateCommentSuccess value)? createCommentSuccess,
    TResult Function(CreateCommentError value)? createCommentError,
    required TResult orElse(),
  }) {
    if (commentsLoading != null) {
      return commentsLoading(this);
    }
    return orElse();
  }
}

abstract class CommentsLoading implements CommentsState {
  const factory CommentsLoading() = _$CommentsLoadingImpl;
}

/// @nodoc
abstract class _$$CommentsSuccessImplCopyWith<$Res> {
  factory _$$CommentsSuccessImplCopyWith(_$CommentsSuccessImpl value,
          $Res Function(_$CommentsSuccessImpl) then) =
      __$$CommentsSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<CommentModel> comments, CommentModel? replyingToComment});
}

/// @nodoc
class __$$CommentsSuccessImplCopyWithImpl<$Res>
    extends _$CommentsStateCopyWithImpl<$Res, _$CommentsSuccessImpl>
    implements _$$CommentsSuccessImplCopyWith<$Res> {
  __$$CommentsSuccessImplCopyWithImpl(
      _$CommentsSuccessImpl _value, $Res Function(_$CommentsSuccessImpl) _then)
      : super(_value, _then);

  /// Create a copy of CommentsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? comments = null,
    Object? replyingToComment = freezed,
  }) {
    return _then(_$CommentsSuccessImpl(
      comments: null == comments
          ? _value._comments
          : comments // ignore: cast_nullable_to_non_nullable
              as List<CommentModel>,
      replyingToComment: freezed == replyingToComment
          ? _value.replyingToComment
          : replyingToComment // ignore: cast_nullable_to_non_nullable
              as CommentModel?,
    ));
  }
}

/// @nodoc

class _$CommentsSuccessImpl implements CommentsSuccess {
  const _$CommentsSuccessImpl(
      {required final List<CommentModel> comments, this.replyingToComment})
      : _comments = comments;

  final List<CommentModel> _comments;
  @override
  List<CommentModel> get comments {
    if (_comments is EqualUnmodifiableListView) return _comments;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_comments);
  }

  @override
  final CommentModel? replyingToComment;

  @override
  String toString() {
    return 'CommentsState.commentsSuccess(comments: $comments, replyingToComment: $replyingToComment)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CommentsSuccessImpl &&
            const DeepCollectionEquality().equals(other._comments, _comments) &&
            (identical(other.replyingToComment, replyingToComment) ||
                other.replyingToComment == replyingToComment));
  }

  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(_comments), replyingToComment);

  /// Create a copy of CommentsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CommentsSuccessImplCopyWith<_$CommentsSuccessImpl> get copyWith =>
      __$$CommentsSuccessImplCopyWithImpl<_$CommentsSuccessImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() commentsLoading,
    required TResult Function(
            List<CommentModel> comments, CommentModel? replyingToComment)
        commentsSuccess,
    required TResult Function(ApiErrorModel error) commentsError,
    required TResult Function() createCommentLoading,
    required TResult Function(CreateCommentResponse response)
        createCommentSuccess,
    required TResult Function(ApiErrorModel error) createCommentError,
  }) {
    return commentsSuccess(comments, replyingToComment);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? commentsLoading,
    TResult? Function(
            List<CommentModel> comments, CommentModel? replyingToComment)?
        commentsSuccess,
    TResult? Function(ApiErrorModel error)? commentsError,
    TResult? Function()? createCommentLoading,
    TResult? Function(CreateCommentResponse response)? createCommentSuccess,
    TResult? Function(ApiErrorModel error)? createCommentError,
  }) {
    return commentsSuccess?.call(comments, replyingToComment);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? commentsLoading,
    TResult Function(
            List<CommentModel> comments, CommentModel? replyingToComment)?
        commentsSuccess,
    TResult Function(ApiErrorModel error)? commentsError,
    TResult Function()? createCommentLoading,
    TResult Function(CreateCommentResponse response)? createCommentSuccess,
    TResult Function(ApiErrorModel error)? createCommentError,
    required TResult orElse(),
  }) {
    if (commentsSuccess != null) {
      return commentsSuccess(comments, replyingToComment);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(CommentsLoading value) commentsLoading,
    required TResult Function(CommentsSuccess value) commentsSuccess,
    required TResult Function(CommentsError value) commentsError,
    required TResult Function(CreateCommentLoading value) createCommentLoading,
    required TResult Function(CreateCommentSuccess value) createCommentSuccess,
    required TResult Function(CreateCommentError value) createCommentError,
  }) {
    return commentsSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(CommentsLoading value)? commentsLoading,
    TResult? Function(CommentsSuccess value)? commentsSuccess,
    TResult? Function(CommentsError value)? commentsError,
    TResult? Function(CreateCommentLoading value)? createCommentLoading,
    TResult? Function(CreateCommentSuccess value)? createCommentSuccess,
    TResult? Function(CreateCommentError value)? createCommentError,
  }) {
    return commentsSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(CommentsLoading value)? commentsLoading,
    TResult Function(CommentsSuccess value)? commentsSuccess,
    TResult Function(CommentsError value)? commentsError,
    TResult Function(CreateCommentLoading value)? createCommentLoading,
    TResult Function(CreateCommentSuccess value)? createCommentSuccess,
    TResult Function(CreateCommentError value)? createCommentError,
    required TResult orElse(),
  }) {
    if (commentsSuccess != null) {
      return commentsSuccess(this);
    }
    return orElse();
  }
}

abstract class CommentsSuccess implements CommentsState {
  const factory CommentsSuccess(
      {required final List<CommentModel> comments,
      final CommentModel? replyingToComment}) = _$CommentsSuccessImpl;

  List<CommentModel> get comments;
  CommentModel? get replyingToComment;

  /// Create a copy of CommentsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CommentsSuccessImplCopyWith<_$CommentsSuccessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CommentsErrorImplCopyWith<$Res> {
  factory _$$CommentsErrorImplCopyWith(
          _$CommentsErrorImpl value, $Res Function(_$CommentsErrorImpl) then) =
      __$$CommentsErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ApiErrorModel error});
}

/// @nodoc
class __$$CommentsErrorImplCopyWithImpl<$Res>
    extends _$CommentsStateCopyWithImpl<$Res, _$CommentsErrorImpl>
    implements _$$CommentsErrorImplCopyWith<$Res> {
  __$$CommentsErrorImplCopyWithImpl(
      _$CommentsErrorImpl _value, $Res Function(_$CommentsErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of CommentsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$CommentsErrorImpl(
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as ApiErrorModel,
    ));
  }
}

/// @nodoc

class _$CommentsErrorImpl implements CommentsError {
  const _$CommentsErrorImpl({required this.error});

  @override
  final ApiErrorModel error;

  @override
  String toString() {
    return 'CommentsState.commentsError(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CommentsErrorImpl &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  /// Create a copy of CommentsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CommentsErrorImplCopyWith<_$CommentsErrorImpl> get copyWith =>
      __$$CommentsErrorImplCopyWithImpl<_$CommentsErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() commentsLoading,
    required TResult Function(
            List<CommentModel> comments, CommentModel? replyingToComment)
        commentsSuccess,
    required TResult Function(ApiErrorModel error) commentsError,
    required TResult Function() createCommentLoading,
    required TResult Function(CreateCommentResponse response)
        createCommentSuccess,
    required TResult Function(ApiErrorModel error) createCommentError,
  }) {
    return commentsError(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? commentsLoading,
    TResult? Function(
            List<CommentModel> comments, CommentModel? replyingToComment)?
        commentsSuccess,
    TResult? Function(ApiErrorModel error)? commentsError,
    TResult? Function()? createCommentLoading,
    TResult? Function(CreateCommentResponse response)? createCommentSuccess,
    TResult? Function(ApiErrorModel error)? createCommentError,
  }) {
    return commentsError?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? commentsLoading,
    TResult Function(
            List<CommentModel> comments, CommentModel? replyingToComment)?
        commentsSuccess,
    TResult Function(ApiErrorModel error)? commentsError,
    TResult Function()? createCommentLoading,
    TResult Function(CreateCommentResponse response)? createCommentSuccess,
    TResult Function(ApiErrorModel error)? createCommentError,
    required TResult orElse(),
  }) {
    if (commentsError != null) {
      return commentsError(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(CommentsLoading value) commentsLoading,
    required TResult Function(CommentsSuccess value) commentsSuccess,
    required TResult Function(CommentsError value) commentsError,
    required TResult Function(CreateCommentLoading value) createCommentLoading,
    required TResult Function(CreateCommentSuccess value) createCommentSuccess,
    required TResult Function(CreateCommentError value) createCommentError,
  }) {
    return commentsError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(CommentsLoading value)? commentsLoading,
    TResult? Function(CommentsSuccess value)? commentsSuccess,
    TResult? Function(CommentsError value)? commentsError,
    TResult? Function(CreateCommentLoading value)? createCommentLoading,
    TResult? Function(CreateCommentSuccess value)? createCommentSuccess,
    TResult? Function(CreateCommentError value)? createCommentError,
  }) {
    return commentsError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(CommentsLoading value)? commentsLoading,
    TResult Function(CommentsSuccess value)? commentsSuccess,
    TResult Function(CommentsError value)? commentsError,
    TResult Function(CreateCommentLoading value)? createCommentLoading,
    TResult Function(CreateCommentSuccess value)? createCommentSuccess,
    TResult Function(CreateCommentError value)? createCommentError,
    required TResult orElse(),
  }) {
    if (commentsError != null) {
      return commentsError(this);
    }
    return orElse();
  }
}

abstract class CommentsError implements CommentsState {
  const factory CommentsError({required final ApiErrorModel error}) =
      _$CommentsErrorImpl;

  ApiErrorModel get error;

  /// Create a copy of CommentsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CommentsErrorImplCopyWith<_$CommentsErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateCommentLoadingImplCopyWith<$Res> {
  factory _$$CreateCommentLoadingImplCopyWith(_$CreateCommentLoadingImpl value,
          $Res Function(_$CreateCommentLoadingImpl) then) =
      __$$CreateCommentLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CreateCommentLoadingImplCopyWithImpl<$Res>
    extends _$CommentsStateCopyWithImpl<$Res, _$CreateCommentLoadingImpl>
    implements _$$CreateCommentLoadingImplCopyWith<$Res> {
  __$$CreateCommentLoadingImplCopyWithImpl(_$CreateCommentLoadingImpl _value,
      $Res Function(_$CreateCommentLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of CommentsState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$CreateCommentLoadingImpl implements CreateCommentLoading {
  const _$CreateCommentLoadingImpl();

  @override
  String toString() {
    return 'CommentsState.createCommentLoading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateCommentLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() commentsLoading,
    required TResult Function(
            List<CommentModel> comments, CommentModel? replyingToComment)
        commentsSuccess,
    required TResult Function(ApiErrorModel error) commentsError,
    required TResult Function() createCommentLoading,
    required TResult Function(CreateCommentResponse response)
        createCommentSuccess,
    required TResult Function(ApiErrorModel error) createCommentError,
  }) {
    return createCommentLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? commentsLoading,
    TResult? Function(
            List<CommentModel> comments, CommentModel? replyingToComment)?
        commentsSuccess,
    TResult? Function(ApiErrorModel error)? commentsError,
    TResult? Function()? createCommentLoading,
    TResult? Function(CreateCommentResponse response)? createCommentSuccess,
    TResult? Function(ApiErrorModel error)? createCommentError,
  }) {
    return createCommentLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? commentsLoading,
    TResult Function(
            List<CommentModel> comments, CommentModel? replyingToComment)?
        commentsSuccess,
    TResult Function(ApiErrorModel error)? commentsError,
    TResult Function()? createCommentLoading,
    TResult Function(CreateCommentResponse response)? createCommentSuccess,
    TResult Function(ApiErrorModel error)? createCommentError,
    required TResult orElse(),
  }) {
    if (createCommentLoading != null) {
      return createCommentLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(CommentsLoading value) commentsLoading,
    required TResult Function(CommentsSuccess value) commentsSuccess,
    required TResult Function(CommentsError value) commentsError,
    required TResult Function(CreateCommentLoading value) createCommentLoading,
    required TResult Function(CreateCommentSuccess value) createCommentSuccess,
    required TResult Function(CreateCommentError value) createCommentError,
  }) {
    return createCommentLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(CommentsLoading value)? commentsLoading,
    TResult? Function(CommentsSuccess value)? commentsSuccess,
    TResult? Function(CommentsError value)? commentsError,
    TResult? Function(CreateCommentLoading value)? createCommentLoading,
    TResult? Function(CreateCommentSuccess value)? createCommentSuccess,
    TResult? Function(CreateCommentError value)? createCommentError,
  }) {
    return createCommentLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(CommentsLoading value)? commentsLoading,
    TResult Function(CommentsSuccess value)? commentsSuccess,
    TResult Function(CommentsError value)? commentsError,
    TResult Function(CreateCommentLoading value)? createCommentLoading,
    TResult Function(CreateCommentSuccess value)? createCommentSuccess,
    TResult Function(CreateCommentError value)? createCommentError,
    required TResult orElse(),
  }) {
    if (createCommentLoading != null) {
      return createCommentLoading(this);
    }
    return orElse();
  }
}

abstract class CreateCommentLoading implements CommentsState {
  const factory CreateCommentLoading() = _$CreateCommentLoadingImpl;
}

/// @nodoc
abstract class _$$CreateCommentSuccessImplCopyWith<$Res> {
  factory _$$CreateCommentSuccessImplCopyWith(_$CreateCommentSuccessImpl value,
          $Res Function(_$CreateCommentSuccessImpl) then) =
      __$$CreateCommentSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({CreateCommentResponse response});
}

/// @nodoc
class __$$CreateCommentSuccessImplCopyWithImpl<$Res>
    extends _$CommentsStateCopyWithImpl<$Res, _$CreateCommentSuccessImpl>
    implements _$$CreateCommentSuccessImplCopyWith<$Res> {
  __$$CreateCommentSuccessImplCopyWithImpl(_$CreateCommentSuccessImpl _value,
      $Res Function(_$CreateCommentSuccessImpl) _then)
      : super(_value, _then);

  /// Create a copy of CommentsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? response = null,
  }) {
    return _then(_$CreateCommentSuccessImpl(
      null == response
          ? _value.response
          : response // ignore: cast_nullable_to_non_nullable
              as CreateCommentResponse,
    ));
  }
}

/// @nodoc

class _$CreateCommentSuccessImpl implements CreateCommentSuccess {
  const _$CreateCommentSuccessImpl(this.response);

  @override
  final CreateCommentResponse response;

  @override
  String toString() {
    return 'CommentsState.createCommentSuccess(response: $response)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateCommentSuccessImpl &&
            (identical(other.response, response) ||
                other.response == response));
  }

  @override
  int get hashCode => Object.hash(runtimeType, response);

  /// Create a copy of CommentsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateCommentSuccessImplCopyWith<_$CreateCommentSuccessImpl>
      get copyWith =>
          __$$CreateCommentSuccessImplCopyWithImpl<_$CreateCommentSuccessImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() commentsLoading,
    required TResult Function(
            List<CommentModel> comments, CommentModel? replyingToComment)
        commentsSuccess,
    required TResult Function(ApiErrorModel error) commentsError,
    required TResult Function() createCommentLoading,
    required TResult Function(CreateCommentResponse response)
        createCommentSuccess,
    required TResult Function(ApiErrorModel error) createCommentError,
  }) {
    return createCommentSuccess(response);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? commentsLoading,
    TResult? Function(
            List<CommentModel> comments, CommentModel? replyingToComment)?
        commentsSuccess,
    TResult? Function(ApiErrorModel error)? commentsError,
    TResult? Function()? createCommentLoading,
    TResult? Function(CreateCommentResponse response)? createCommentSuccess,
    TResult? Function(ApiErrorModel error)? createCommentError,
  }) {
    return createCommentSuccess?.call(response);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? commentsLoading,
    TResult Function(
            List<CommentModel> comments, CommentModel? replyingToComment)?
        commentsSuccess,
    TResult Function(ApiErrorModel error)? commentsError,
    TResult Function()? createCommentLoading,
    TResult Function(CreateCommentResponse response)? createCommentSuccess,
    TResult Function(ApiErrorModel error)? createCommentError,
    required TResult orElse(),
  }) {
    if (createCommentSuccess != null) {
      return createCommentSuccess(response);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(CommentsLoading value) commentsLoading,
    required TResult Function(CommentsSuccess value) commentsSuccess,
    required TResult Function(CommentsError value) commentsError,
    required TResult Function(CreateCommentLoading value) createCommentLoading,
    required TResult Function(CreateCommentSuccess value) createCommentSuccess,
    required TResult Function(CreateCommentError value) createCommentError,
  }) {
    return createCommentSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(CommentsLoading value)? commentsLoading,
    TResult? Function(CommentsSuccess value)? commentsSuccess,
    TResult? Function(CommentsError value)? commentsError,
    TResult? Function(CreateCommentLoading value)? createCommentLoading,
    TResult? Function(CreateCommentSuccess value)? createCommentSuccess,
    TResult? Function(CreateCommentError value)? createCommentError,
  }) {
    return createCommentSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(CommentsLoading value)? commentsLoading,
    TResult Function(CommentsSuccess value)? commentsSuccess,
    TResult Function(CommentsError value)? commentsError,
    TResult Function(CreateCommentLoading value)? createCommentLoading,
    TResult Function(CreateCommentSuccess value)? createCommentSuccess,
    TResult Function(CreateCommentError value)? createCommentError,
    required TResult orElse(),
  }) {
    if (createCommentSuccess != null) {
      return createCommentSuccess(this);
    }
    return orElse();
  }
}

abstract class CreateCommentSuccess implements CommentsState {
  const factory CreateCommentSuccess(final CreateCommentResponse response) =
      _$CreateCommentSuccessImpl;

  CreateCommentResponse get response;

  /// Create a copy of CommentsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CreateCommentSuccessImplCopyWith<_$CreateCommentSuccessImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CreateCommentErrorImplCopyWith<$Res> {
  factory _$$CreateCommentErrorImplCopyWith(_$CreateCommentErrorImpl value,
          $Res Function(_$CreateCommentErrorImpl) then) =
      __$$CreateCommentErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ApiErrorModel error});
}

/// @nodoc
class __$$CreateCommentErrorImplCopyWithImpl<$Res>
    extends _$CommentsStateCopyWithImpl<$Res, _$CreateCommentErrorImpl>
    implements _$$CreateCommentErrorImplCopyWith<$Res> {
  __$$CreateCommentErrorImplCopyWithImpl(_$CreateCommentErrorImpl _value,
      $Res Function(_$CreateCommentErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of CommentsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$CreateCommentErrorImpl(
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as ApiErrorModel,
    ));
  }
}

/// @nodoc

class _$CreateCommentErrorImpl implements CreateCommentError {
  const _$CreateCommentErrorImpl({required this.error});

  @override
  final ApiErrorModel error;

  @override
  String toString() {
    return 'CommentsState.createCommentError(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateCommentErrorImpl &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  /// Create a copy of CommentsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateCommentErrorImplCopyWith<_$CreateCommentErrorImpl> get copyWith =>
      __$$CreateCommentErrorImplCopyWithImpl<_$CreateCommentErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() commentsLoading,
    required TResult Function(
            List<CommentModel> comments, CommentModel? replyingToComment)
        commentsSuccess,
    required TResult Function(ApiErrorModel error) commentsError,
    required TResult Function() createCommentLoading,
    required TResult Function(CreateCommentResponse response)
        createCommentSuccess,
    required TResult Function(ApiErrorModel error) createCommentError,
  }) {
    return createCommentError(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? commentsLoading,
    TResult? Function(
            List<CommentModel> comments, CommentModel? replyingToComment)?
        commentsSuccess,
    TResult? Function(ApiErrorModel error)? commentsError,
    TResult? Function()? createCommentLoading,
    TResult? Function(CreateCommentResponse response)? createCommentSuccess,
    TResult? Function(ApiErrorModel error)? createCommentError,
  }) {
    return createCommentError?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? commentsLoading,
    TResult Function(
            List<CommentModel> comments, CommentModel? replyingToComment)?
        commentsSuccess,
    TResult Function(ApiErrorModel error)? commentsError,
    TResult Function()? createCommentLoading,
    TResult Function(CreateCommentResponse response)? createCommentSuccess,
    TResult Function(ApiErrorModel error)? createCommentError,
    required TResult orElse(),
  }) {
    if (createCommentError != null) {
      return createCommentError(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(CommentsLoading value) commentsLoading,
    required TResult Function(CommentsSuccess value) commentsSuccess,
    required TResult Function(CommentsError value) commentsError,
    required TResult Function(CreateCommentLoading value) createCommentLoading,
    required TResult Function(CreateCommentSuccess value) createCommentSuccess,
    required TResult Function(CreateCommentError value) createCommentError,
  }) {
    return createCommentError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(CommentsLoading value)? commentsLoading,
    TResult? Function(CommentsSuccess value)? commentsSuccess,
    TResult? Function(CommentsError value)? commentsError,
    TResult? Function(CreateCommentLoading value)? createCommentLoading,
    TResult? Function(CreateCommentSuccess value)? createCommentSuccess,
    TResult? Function(CreateCommentError value)? createCommentError,
  }) {
    return createCommentError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(CommentsLoading value)? commentsLoading,
    TResult Function(CommentsSuccess value)? commentsSuccess,
    TResult Function(CommentsError value)? commentsError,
    TResult Function(CreateCommentLoading value)? createCommentLoading,
    TResult Function(CreateCommentSuccess value)? createCommentSuccess,
    TResult Function(CreateCommentError value)? createCommentError,
    required TResult orElse(),
  }) {
    if (createCommentError != null) {
      return createCommentError(this);
    }
    return orElse();
  }
}

abstract class CreateCommentError implements CommentsState {
  const factory CreateCommentError({required final ApiErrorModel error}) =
      _$CreateCommentErrorImpl;

  ApiErrorModel get error;

  /// Create a copy of CommentsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CreateCommentErrorImplCopyWith<_$CreateCommentErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
